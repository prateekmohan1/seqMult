//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart1/starter-01-HO/primitives/seqMult.vp
//  Source template: seqMult
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/////////////
// seqMult.vp
//
// bitWidth (_GENESIS2_DECLARATION_PRIORITY_) = 16
//


// Use built in module name using Gen2 variable mname

module seqMult (
	input logic [15:0] a,
	input logic [15:0] b,
	input logic ab_valid,
	output logic ab_ready,

	input logic clk,
	input logic rst,

	output logic [32:0] z,
	output logic z_valid
		);

	//Initialize States
	parameter SIZE = 3;
	parameter S0=3'b000, S1=3'b001, S2=3'b010, S3=3'b011, S4=3'b100, S5=3'b101, S6=3'b110;

	//Counter
	logic [5:0] count;
	
	//Flop
	logic [15:0] a_flop;
	logic [15:0] b_flop;

	//Intermediate value of z
	logic [15:0] z_AND;

	//Next_State, Current state variable
	logic [SIZE-1:0] state;
	logic [SIZE-1:0] next_state;

	//Flop for storing a and b
    always_ff @(posedge clk) begin
        if (ab_ready && ab_valid) begin
            a_flop <= a;
            b_flop <= b;
        end
    end

	//Compute the z_AND to be used later, continuously used
    	assign z_AND[0] = z[0] & b_flop[0];
    	assign z_AND[1] = z[0] & b_flop[1];
    	assign z_AND[2] = z[0] & b_flop[2];
    	assign z_AND[3] = z[0] & b_flop[3];
    	assign z_AND[4] = z[0] & b_flop[4];
    	assign z_AND[5] = z[0] & b_flop[5];
    	assign z_AND[6] = z[0] & b_flop[6];
    	assign z_AND[7] = z[0] & b_flop[7];
    	assign z_AND[8] = z[0] & b_flop[8];
    	assign z_AND[9] = z[0] & b_flop[9];
    	assign z_AND[10] = z[0] & b_flop[10];
    	assign z_AND[11] = z[0] & b_flop[11];
    	assign z_AND[12] = z[0] & b_flop[12];
    	assign z_AND[13] = z[0] & b_flop[13];
    	assign z_AND[14] = z[0] & b_flop[14];
    	assign z_AND[15] = z[0] & b_flop[15];


	//Outputs and flops
	always_ff @(posedge clk) begin
		if (~rst) begin
			z_valid <= 0;
			z <= 0;
		end
		else begin
			unique case (state)
			S0: begin
				z_valid <= 0;
				z <= 0;
			end
			S1: begin
				//If you are in this state, then at the clock edge, ab_ready and ab_valid were high
				//Thus, you can store the values of a_flop and b_flop
				//Initialize count to 0	
				count <= 0;

				//Fill the bottom rows of z
				z[15:0] <= a_flop;
			end
			S2: begin
				//Here, the z can be added to the z_AND
				z[32:16] <= z[32:16] + z_AND;
			end
			S3: begin
				//Now, you can shift z 
				z <= z >> 1;
				
				//Increment count
				count <= count + 1;

				if (count == 15) begin
					z_valid <= 1;
				end
			end
			endcase
		end
	end

	always_comb begin
		unique case (state)
		S0: begin
			ab_ready = 1;
			if (ab_valid) begin            //What happens if ab_valid goes high right at the clock edge?
                                next_state = S1;
                        end
                        else begin
                                next_state = S0;
                        end
		end
		S1: begin
			ab_ready = 0;
			next_state = S2;
		end
		S2: begin
			next_state = S3;
		end
		S3: begin
			if (count == 15) begin
				next_state = S0;
			end
			else begin
				next_state = S2;				
			end
		end
		endcase
	end

    //Flip Flop for state
    always_ff @ (posedge clk) begin
        if (~rst) begin
            state <= S0;
        end
        else begin
            state <= next_state;
        end
    end

//Empty module
endmodule: seqMult
